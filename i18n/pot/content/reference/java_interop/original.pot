# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2016-10-21 08:45+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: en/content/reference/special_forms.adoc:15
#: en/content/reference/sequences.adoc:15 en/content/reference/metadata.adoc:15
#: en/content/reference/reader.adoc:13 en/content/reference/transients.adoc:16
#: en/content/reference/macros.adoc:15 en/content/reference/refs.adoc:15
#: en/content/reference/compilation.adoc:16
#: en/content/reference/other_functions.adoc:17
#: en/content/reference/other_libraries.adoc:16
#: en/content/reference/java_interop.adoc:15
#: en/content/reference/data_structures.adoc:16
#: en/content/reference/datatypes.adoc:16 en/content/reference/agents.adoc:16
#: en/content/reference/protocols.adoc:15 en/content/reference/reducers.adoc:15
#: en/content/reference/lazy.adoc:12 en/content/reference/repl_and_main.adoc:16
#: en/content/reference/transducers.adoc:15 en/content/reference/vars.adoc:16
#: en/content/reference/namespaces.adoc:15 en/content/reference/libs.adoc:16
#: en/content/reference/multimethods.adoc:15
#: en/content/about/functional_programming.adoc:15
#: en/content/about/dynamic.adoc:16 en/content/about/spec.adoc:16
#: en/content/about/rationale.adoc:13 en/content/about/state.adoc:16
#: en/content/guides/reader_conditionals.adoc:10 en/content/guides/spec.adoc:11
#: en/content/guides/destructuring.adoc:11 en/content/guides/faq.adoc:11
msgid "toc::[]"
msgstr ""

#. type: Plain text
#: en/content/reference/metadata.adoc:23 en/content/reference/metadata.adoc:29
#: en/content/reference/evaluation.adoc:62
#: en/content/reference/evaluation.adoc:73
#: en/content/reference/java_interop.adoc:76
#: en/content/reference/java_interop.adoc:96
#: en/content/reference/java_interop.adoc:109
#: en/content/reference/java_interop.adoc:131
#: en/content/reference/java_interop.adoc:138
#: en/content/reference/java_interop.adoc:152
#: en/content/reference/java_interop.adoc:193 en/content/reference/libs.adoc:63
#: en/content/community/editing.adoc:71 en/content/community/editing.adoc:85
#: en/content/community/editing.adoc:103 en/content/community/editing.adoc:121
#: en/content/community/editing.adoc:131
msgid "''''"
msgstr ""

#. type: Title =
#: en/content/reference/java_interop.adoc:1
#, no-wrap
msgid "Java Interop"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:4
msgid "Rich Hickey 2016-02-25"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:17
#, no-wrap
msgid "Member access"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:25
#, no-wrap
msgid ""
"**(.instanceMember instance args*)**\n"
"**(.instanceMember Classname args*)**\n"
"**(.-instanceField instance)**\n"
"**(Classname/staticMethod args*)**\n"
"**Classname/staticField**\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:38
#, no-wrap
msgid ""
"(.toUpperCase \"fred\")\n"
"-> \"FRED\"\n"
"(.getName String)\n"
"-> \"java.lang.String\"\n"
"(.-x (java.awt.Point. 1 2))\n"
"-> 1\n"
"(System/getProperty \"java.vm.version\")\n"
"-> \"1.6.0_07-b06-57\"\n"
"Math/PI\n"
"-> 3.141592653589793\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:41
msgid ""
"The preferred idiomatic forms for accessing field or method members are "
"given above. The instance member form works for both fields and methods. The "
"instanceField form is preferred for fields and required if both a field and "
"a 0-argument method of the same name exist. They all expand into calls to "
"the dot operator (described below) at macroexpansion time. The expansions "
"are as follows:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:50
#, no-wrap
msgid ""
"(.instanceMember instance args*) ==> (. instance instanceMember args*)\n"
"(.instanceMember Classname args*) ==>\n"
"    (. (identity Classname) instanceMember args*)\n"
"(.-instanceField instance) ==> (. instance -instanceField)\n"
"(Classname/staticMethod args*) ==> (. Classname staticMethod args*)\n"
"Classname/staticField ==> (. Classname staticField)\n"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:52
#, no-wrap
msgid "The Dot special form"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:60
#, no-wrap
msgid ""
"*(_._ instance-expr member-symbol)*\n"
"*(_._ Classname-symbol member-symbol)*\n"
"*(_._ instance-expr -field-symbol)*\n"
"*(_._ instance-expr (method-symbol args*))* or *(_._ instance-expr method-symbol args*)*\n"
"*(_._ Classname-symbol (method-symbol args*))* or *(_._ Classname-symbol method-symbol args*)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:62
#: en/content/reference/java_interop.adoc:115
msgid "Special form."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:64
msgid ""
"The '.' special form is the basis for access to Java. It can be considered a "
"member-access operator, and/or read as 'in the scope of'."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:66
msgid ""
"If the first operand is a symbol that resolves to a class name, the access "
"is considered to be to a static member of the named class. Note that nested "
"classes are named EnclosingClass$NestedClass, per the JVM spec. Otherwise it "
"is presumed to be an instance member and the first argument is evaluated to "
"produce the target object."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:68
msgid ""
"If the second operand is a symbol and no args are supplied it is taken to be "
"a field access - the name of the field is the name of the symbol, and the "
"value of the expression is the value of the field, _unless_ there is a no "
"argument public method of the same name, in which case it resolves to a call "
"to the method. If the second operand is a symbol starting with _-_, the "
"member-symbol will resolve only as field access (never as a 0-arity method) "
"and should be preferred when that is the intent."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:70
msgid ""
"If the second operand is a list, or args are supplied, it is taken to be a "
"method call. The first element of the list must be a simple symbol, and the "
"name of the method is the name of the symbol. The args, if any, are "
"evaluated from left to right, and passed to the matching method, which is "
"called, and its value returned. If the method has a void return type, the "
"value of the expression will be _**nil**_. Note that placing the method name "
"in a list with any args is optional in the canonic form, but can be useful "
"to gather args in macros built upon the form."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:72
msgid ""
"Note that boolean return values will be turned into Booleans, chars will "
"become Characters, and numeric primitives will become Numbers unless they "
"are immediately consumed by a method taking a primitive."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:74
msgid ""
"The member access forms given at the top of this section are preferred for "
"use in all cases other than in macros."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:80
#, no-wrap
msgid ""
"*(_.._ instance-expr member+)*\n"
"*(_.._ Classname-symbol member+)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:82
msgid "member => fieldName-symbol or (instanceMethodName-symbol args*)"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:84
msgid ""
"Macro. Expands into a member access (.) of the first member on the first "
"argument, followed by the next member on the result, etc. For instance:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:86
msgid "`(.. System (getProperties) (get \"os.name\"))`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:88
msgid "expands to:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:90
msgid "`(. (. System (getProperties)) (get \"os.name\"))`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:92
msgid ""
"but is easier to write, read, and understand. See also the http://clojure."
"github.com/clojure/clojure.core-api.html#clojure.core/%2d%3e[pass:[->]] "
"macro which can be used similarly:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:94
msgid "`(-> (System/getProperties) (.get \"os.name\"))`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:98
#, no-wrap
msgid "*(_doto_ instance-expr (instanceMethodName-symbol args*)*)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:100
msgid ""
"Macro. Evaluates instance-expr then calls all of the methods/functions with "
"the supplied arguments in succession on the resulting object, returning it."
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:105
#, no-wrap
msgid ""
"(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))\n"
"-> {a=1, b=2}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:113
#, no-wrap
msgid ""
"*(Classname. args*)*\n"
"*(_new_ Classname args*)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:117
msgid ""
"The args, if any, are evaluated from left to right, and passed to the "
"constructor of the class named by Classname. The constructed object is "
"returned."
msgstr ""

#. type: Title ===
#: en/content/reference/java_interop.adoc:118
#, no-wrap
msgid "Alternative Macro Syntax"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:121
msgid ""
"As shown, in addition to the canonic special form new, Clojure supports "
"special macroexpansion of symbols containing '.':"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:123
msgid "`(new Classname args*)`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:125
msgid "can be written"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:127
msgid "`(Classname. args*) ;note trailing dot`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:129
msgid "the latter expanding into the former at macro expansion time."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:133
#, no-wrap
msgid "*(_instance?_ Class expr)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:135
msgid ""
"Evaluates expr and tests if it is an instance of the class. Returns true or "
"false"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:142
#, no-wrap
msgid ""
"*(_set!_ (. instance-expr instanceFieldName-symbol) expr)*\n"
"*(_set!_ (. Classname-symbol staticFieldName-symbol) expr)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:144 en/content/reference/vars.adoc:65
msgid "Assignment special form."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:146
msgid ""
"When the first operand is a field member access form, the assignment is to "
"the corresponding field. If it is an instance field, the instance expr will "
"be evaluated, then the expr."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:148
msgid "In all cases the value of expr is returned."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:150 en/content/reference/vars.adoc:69
msgid ""
"Note - _you cannot assign to function params or local bindings. Only Java "
"fields, Vars, Refs and Agents are mutable in Clojure_."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:154
#, no-wrap
msgid "*(_memfn_ method-name arg-names*)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:156
msgid ""
"Macro. Expands into code that creates a fn that expects to be passed an "
"object and any args and calls the named instance method on the object "
"passing the args. Use when you want to treat a Java method as a first-class "
"fn."
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:161
#, no-wrap
msgid ""
"(map (memfn charAt i) [\"fred\" \"ethel\" \"lucy\"] [1 2 3])\n"
"-> (\\r \\h \\y)\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:164
msgid ""
"Note it almost always preferable to do this directly now, with syntax like:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:169
#, no-wrap
msgid ""
"(map #(.charAt %1 %2) [\"fred\" \"ethel\" \"lucy\"] [1 2 3])\n"
"-> (\\r \\h \\y)\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:173
msgid "'''' *(_bean_ obj)*"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:175
msgid ""
"Takes a Java object and returns a read-only implementation of the map "
"abstraction based upon its JavaBean properties."
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:182
#, no-wrap
msgid ""
"(bean java.awt.Color/black)\n"
"-> {:RGB -16777216, :alpha 255, :blue 0, :class java.awt.Color,\n"
"    :colorSpace #object[java.awt.color.ICC_ColorSpace 0x5cb42b \"java.awt.color.ICC_ColorSpace@5cb42b\"],\n"
"    :green 0, :red 0, :transparency 1}\n"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:184
#, no-wrap
msgid "Support for Java in Clojure Library Functions"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:187
msgid ""
"Many of the Clojure library functions have defined semantics for objects of "
"Java types. contains? and get work on Java Maps, arrays, Strings, the latter "
"two with integer keys. count works on Java Strings, Collections and arrays. "
"nth works on Java Strings, Lists and arrays. seq works on Java reference "
"arrays, Iterables and Strings. Since much of the rest of the library is "
"built upon these functions, there is great support for using Java objects in "
"Clojure algorithms."
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:188
#, no-wrap
msgid "Implementing Interfaces and Extending Classes"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:191
msgid ""
"Clojure supports the dynamic creation of objects that implement one or more "
"interfaces and/or extend a class with the http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/proxy[proxy] macro. The resulting objects "
"are of an anonymous class. You can also generate statically-named classes "
"and .class files with http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/gen-class[gen-class]. As of Clojure 1.2, http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/reify[reify] is also "
"available for implementing interfaces."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:195
#, no-wrap
msgid "*( _proxy_ [class-and-interfaces] [args] fs+)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:199
msgid ""
"class-and-interfaces - a vector of class names + args - a (possibly empty) "
"vector of arguments to the superclass constructor. + f => (name [params*] "
"body) or (name ([params*] body) ([params+] body) ...)"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:201
msgid "Macro"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:203
msgid ""
"Expands to code which creates a instance of a proxy class that implements "
"the named class/interface(s) by calling the supplied fns. A single class, if "
"provided, must be first. If not provided it defaults to Object. The "
"interfaces names must be valid interface types. If a method fn is not "
"provided for a class method, the superclass method will be called. If a "
"method fn is not provided for an interface method, an "
"UnsupportedOperationException will be thrown should it be called. Method fns "
"are closures and can capture the environment in which proxy is called. Each "
"method fn takes an additional implicit first arg, which is bound to this. "
"Note that while method fns can be provided to override protected methods, "
"they have no other access to protected members, nor to super, as these "
"capabilities cannot be proxied."
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:204
#, no-wrap
msgid "Arrays"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:207
msgid ""
"Clojure supports the creation, reading and modification of Java arrays. It "
"is recommended that you limit use of arrays to interop with Java libraries "
"that require them as arguments or use them as return values."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:209
msgid ""
"Note that many other Clojure functions work with arrays such as via the "
"<<sequences#,seq library>>. The functions listed here exist for initial "
"creation of arrays, or to support mutation or higher performance operations "
"on arrays."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:217
msgid ""
"Create array from existing collection: http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/aclone[aclone] http://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/amap[amap] http://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/to-array[to-array] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/to-array-2d[to-"
"array-2d] http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/into-array[into-array] Multi-dimensional array support: http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/aget[aget] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/aset[aset] "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/to-"
"array-2d[to-array-2d] http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/make-array[make-array] Type-specific array constructors: "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/boolean-"
"array[boolean-array] http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/byte-array[byte-array] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/char-array[char-array] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/double-array[double-"
"array] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"float-array[float-array] http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/int-array[int-array] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/long-array[long-array] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/object-array[object-"
"array] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"short-array[short-array] Primitive array casts: http://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/booleans[booleans] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/bytes[bytes] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/chars[chars] "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"doubles[doubles] http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/floats[floats] http://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/ints[ints] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/longs[longs] http://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/shorts[shorts] Mutate an array: "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"aset[aset] Process an existing array: http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/aget[aget] http://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/alength[alength] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/amap[amap] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/areduce[areduce]"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:219
#, no-wrap
msgid "Type Hints"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:222
msgid ""
"Clojure supports the use of type hints to assist the compiler in avoiding "
"reflection in performance-critical areas of code. Normally, one should avoid "
"the use of type hints until there is a known performance bottleneck. Type "
"hints are metadata tags placed on symbols or expressions that are consumed "
"by the compiler. They can be placed on function parameters, let-bound names, "
"var names (when defined), and expressions:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:227
#, no-wrap
msgid ""
"(defn len [x]\n"
"  (.length x))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:230
#, no-wrap
msgid ""
"(defn len2 [^String x]\n"
"  (.length x))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:237
#, no-wrap
msgid ""
"user=> (time (reduce + (map len (repeat 1000000 \"asdf\"))))\n"
"\"Elapsed time: 3007.198 msecs\"\n"
"4000000\n"
"user=> (time (reduce + (map len2 (repeat 1000000 \"asdf\"))))\n"
"\"Elapsed time: 308.045 msecs\"\n"
"4000000\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:240
msgid ""
"Once a type hint has been placed on an identifier or expression, the "
"compiler will try to resolve any calls to methods thereupon at compile time. "
"In addition, the compiler will track the use of any return values and infer "
"types for their use and so on, so very few hints are needed to get a fully "
"compile-time resolved series of calls. Note that type hints are not needed "
"for static members (or their return values!) as the compiler always has the "
"type for statics."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:242
msgid ""
"There is a pass:[*warn-on-reflection*] flag (defaults to false) which will "
"cause the compiler to warn you when it can't resolve to a direct call:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:247
#, no-wrap
msgid ""
"(set! *warn-on-reflection* true)\n"
"-> true\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:251
#, no-wrap
msgid ""
"(defn foo [s] (.charAt s 1))\n"
"-> Reflection warning, line: 2 - call to charAt can't be resolved.\n"
"-> #user/foo\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:254
#, no-wrap
msgid ""
"(defn foo [^String s] (.charAt s 1))\n"
"-> #user/foo\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:257
msgid ""
"For function return values, the type hint can be placed before the arguments "
"vector:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:264
#, no-wrap
msgid ""
"(defn hinted\n"
"  (^String [])\n"
"  (^Integer [a])\n"
"  (^java.util.List [a & args]))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:266
#, no-wrap
msgid "-> #user/hinted\n"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:269
#, no-wrap
msgid "Aliases"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:275
msgid ""
"Clojure provides aliases for primitive Java types and arrays which do not "
"have typical representations as Java class names.  The types are represented "
"according to the specification of http://docs.oracle.com/javase/specs/jvms/"
"se7/html/jvms-4.html#jvms-4.3.2-200[Java Field Descriptors].  For example, "
"byte arrays (byte-array []) have a type of \"[B\"."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:277
msgid "int - A primitive int"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:278
msgid "ints - An int array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:279
msgid "long - A primitive long"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:280
msgid "longs - A long array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:281
msgid "float - A primitive float"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:282
msgid "floats - A float array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:283
msgid "double - A primitive double"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:284
msgid "doubles - A double array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:285
msgid "void - A void return"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:286
msgid "short - A primitive short"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:287
msgid "shorts - A short array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:288
msgid "boolean - A primitive boolean"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:289
msgid "booleans - A boolean array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:290
msgid "byte - A primitive byte"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:291
msgid "bytes - A byte array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:292
msgid "char - A primitive character"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:293
msgid "chars - A character array"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:295
#, no-wrap
msgid "Support for Java Primitives"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:298
msgid ""
"Clojure has support for high-performance manipulation of, and arithmetic "
"involving, Java primitive types in local contexts. All Java primitive types "
"are supported: int, float, long, double, boolean, char, short, and byte."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:300
msgid ""
"_**let**_/_**loop**_-bound locals can be of primitive types, having the "
"inferred, possibly primitive type of their init-form."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:301
msgid ""
"_**recur**_ forms that rebind primitive locals do so without boxing, and do "
"type-checking for same primitive type."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:302
msgid ""
"Arithmetic (+,-,*,/,inc,dec,<,<=,>,>= etc) is overloaded for primitive types "
"where semantics are same."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:303
msgid ""
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"aget[aget] / http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/aset[aset] are overloaded for arrays of primitives"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:304
msgid ""
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"aclone[aclone], http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/alength[alength] functions for arrays of primitives"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:305
msgid ""
"constructor functions for primitive arrays: http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/float-array[float-array], http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/int-array[int-array], "
"etc."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:306
msgid "Type hints for primitive arrays - +^ints, ^floats+, etc."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:307
msgid ""
"Coercion ops http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/int[int], http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/float[float], etc. produce primitives when consumer can "
"take primitive"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:308
msgid ""
"The http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"num[num] coercion function boxes primitives to force generic arithmetic"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:309
msgid ""
"Array cast functions http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/ints[ints] http://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/longs[longs], etc. which produce +int[]+, +long[]+, "
"etc."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:310
msgid ""
"A set of \"unchecked\" operations for utmost performing, but potentially "
"unsafe, integer (int/long) ops: http://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/unchecked-multiply[unchecked-multiply] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/unchecked-"
"dec[unchecked-dec] http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/unchecked-inc[unchecked-inc] http://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/unchecked-negate[unchecked-"
"negate] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"unchecked-add[unchecked-add] http://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/unchecked-subtract[unchecked-subtract] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/unchecked-"
"remainder[unchecked-remainder] http://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/unchecked-divide[unchecked-divide]"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:311
msgid ""
"A dynamic var to automatically swap safe operations with unchecked "
"operations: http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/%2Aunchecked-math%2A[pass:[*unchecked-math*]]"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:312
msgid ""
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"amap[amap] and http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/areduce[areduce] macros for functionally (i.e. non-"
"destructively) processing one or more arrays in order to produce a new array "
"or aggregate value respectively."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:314
msgid "Rather than write this Java:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:322
#, no-wrap
msgid ""
"static public float asum(float[] xs){\n"
"  float ret = 0;\n"
"  for(int i = 0; i < xs.length; i++)\n"
"    ret += xs[i];\n"
"  return ret;\n"
"}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:325
msgid "you can write this Clojure:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:331
#, no-wrap
msgid ""
"(defn asum [^floats xs]\n"
"  (areduce xs i ret (float 0)\n"
"    (+ ret (aget xs i))))\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:334
msgid ""
"and the resulting code is exactly the same speed (when run with java -"
"server)."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:336
msgid ""
"The best aspect of this is that you need not do anything special in your "
"initial coding. Quite often these optimizations are unneeded. Should a bit "
"of code be a bottleneck, you can speed it up with minor adornment:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:344
#, no-wrap
msgid ""
"(defn foo [n]\n"
"  (loop [i 0]\n"
"    (if (< i n)\n"
"      (recur (inc i))\n"
"      i)))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:348
#, no-wrap
msgid ""
"(time (foo 100000))\n"
"\"Elapsed time: 0.391 msecs\"\n"
"100000\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:355
#, no-wrap
msgid ""
"(defn foo2 [n]\n"
"  (let [n (int n)]\n"
"    (loop [i (int 0)]\n"
"      (if (< i n)\n"
"        (recur (inc i))\n"
"        i))))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:359
#, no-wrap
msgid ""
"(time (foo2 100000))\n"
"\"Elapsed time: 0.084 msecs\"\n"
"100000\n"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:361
#, no-wrap
msgid "Coercions"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:364
msgid ""
"At times it is necessary to have a value of a particular primitive type. "
"These coercion functions yield a value of the indicated type as long as such "
"a coercion is possible: http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/bigdec[bigdec] http://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/bigint[bigint] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/boolean[boolean] http://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/byte[byte] http://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/char[char] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/double[double] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/float[float] "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/int[int] "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"long[long] http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/num[num] http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/short[short]"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:366
#, no-wrap
msgid "Some optimization tips"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:369
msgid ""
"All arguments are passed to Clojure fns as objects, so there's no point to "
"putting non-array primitive type hints on fn args. Instead, use the let "
"technique shown to place args in primitive locals if they need to "
"participate in primitive arithmetic in the body."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:370
msgid ""
"(let [foo (int bar)] ...) is the correct way to get a primitive local. Do "
"not use ^Integer etc."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:371
msgid ""
"Don't rush to unchecked math unless you want truncating operations. HotSpot "
"does a good job at optimizing the overflow check, which will yield an "
"exception instead of silent truncation. On a typical example, that has about "
"a 5% difference in speed - well worth it. Also, people reading your code "
"don't know if you are using unchecked for truncation or performance - best "
"to reserve it for the former and comment if the latter."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:372
msgid ""
"There's usually no point in trying to optimize an outer loop, in fact it can "
"hurt you as you'll be representing things as primitives which just have to "
"be re-boxed in order to become args to the inner call. The only exception is "
"reflection warnings - you must get rid of them in any code that gets called "
"frequently."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:373
msgid ""
"Almost every time someone presents something they are trying to optimize "
"with hints, the faster version has far fewer hints than the original. If a "
"hint doesn't improve things in the end - take it out."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:374
msgid ""
"Many people seem to presume only the unchecked- ops do primitive arithmetic "
"- not so. When the args are primitive locals, regular + and * etc do "
"primitive math with an overflow check - fast _and_ safe."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:375
msgid ""
"So, the simplest route to fast math is to leave the operators alone and just "
"make sure the source literals and locals are primitive. Arithmetic on "
"primitives yields primitives. If you've got a loop (which you probably do if "
"you need to optimize) make sure the loop locals are primitives first - then "
"if you accidentally are producing a boxed intermediate result you'll get an "
"error on recur. Don't solve that error by coercing your intermediate result, "
"instead, figure out what argument or local is not primitive."
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:376
#, no-wrap
msgid "Simple XML Support"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:378
msgid ""
"Included with the distribution is simple XML support, found in the src/xml."
"clj file. All names from this file are in the xml namespace."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:381
msgid "'''' *(_parse_ source)*"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:383
msgid ""
"Parses and loads the source, which can be a File, InputStream or String "
"naming a URI. Returns a tree of the xml/element struct-map, which has the "
"keys :tag, :attrs, and :content. and accessor fns tag, attrs, and content."
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:388
#, no-wrap
msgid ""
"(xml/parse \"/Users/rich/dev/clojure/build.xml\")\n"
"-> {:tag :project, :attrs {:name \"clojure\", :default \"jar\"}, :content [{:tag :description, ...\n"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:390
#, no-wrap
msgid "Calling Clojure From Java"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:393
msgid ""
"The http://clojure.github.io/clojure/javadoc[clojure.java.api] package "
"provides a minimal interface to bootstrap Clojure access from other JVM "
"languages. It does this by providing:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:395
msgid ""
"The ability to use Clojure's namespaces to locate an arbitrary var, "
"returning the var's clojure.lang.IFn interface."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:396
msgid "A convenience method read for reading data using Clojure's edn reader"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:398
msgid ""
"IFns provide complete access to Clojure's APIs. You can also access any "
"other library written in Clojure, after adding either its source or compiled "
"form to the classpath."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:400
msgid ""
"The public Java API for Clojure consists of the following classes and "
"interfaces:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:402
msgid ""
"http://clojure.github.io/clojure/javadoc/clojure/java/api/Clojure."
"html[clojure.java.api.Clojure]"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:403
msgid ""
"http://clojure.github.io/clojure/javadoc/clojure/lang/IFn.html[clojure.lang."
"IFn]"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:405
msgid ""
"All other Java classes should be treated as implementation details, and "
"applications should avoid relying on them."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:407
msgid "To lookup and call a Clojure function:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:411
#, no-wrap
msgid ""
"IFn plus = Clojure.var(\"clojure.core\", \"+\");\n"
"plus.invoke(1, 2);\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:413
msgid ""
"Functions in clojure.core are automatically loaded. Other namespaces can be "
"loaded via require:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:417
#, no-wrap
msgid ""
"IFn require = Clojure.var(\"clojure.core\", \"require\");\n"
"require.invoke(Clojure.read(\"clojure.set\"));\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:419
msgid ""
"IFns can be passed to higher order functions, e.g. the example below passes "
"plus to read:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:424
#, no-wrap
msgid ""
"IFn map = Clojure.var(\"clojure.core\", \"map\");\n"
"IFn inc = Clojure.var(\"clojure.core\", \"inc\");\n"
"map.invoke(inc, Clojure.read(\"[1 2 3]\"));\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:426
msgid ""
"Most IFns in Clojure refer to functions. A few, however, refer to non-"
"function data values. To access these, use deref instead of fn:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:431
#, no-wrap
msgid ""
"IFn printLength = Clojure.var(\"clojure.core\", \"*print-length*\");\n"
"IFn deref = Clojure.var(\"clojure.core\", \"deref\");\n"
"deref.invoke(printLength);\n"
msgstr ""
